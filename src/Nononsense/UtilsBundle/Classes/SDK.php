<?php/** * Docxpresso SERVER SDK * * @copyright  Copyright (c) 2017 No-nonsense Labs (http://www.nononsenselabs.com) * @license    MIT * @link       https://opensource.org/licenses/MIT * @version    1.0 * @since      1.0 */namespace Nononsense\UtilsBundle\Classes;/** * A collection of methods that simplify the data exchange and communication * with the Docxpresso SERVER package */class SDK{    /**     * Construct     *     * @param array $options with the following keys and values     *      'pKey' => (string) the private key of your Docxpresso SERVER      *       installation     *      'docxpressoInstallation' => (string) the URL of your Docxpresso     *      SERVER installation     *      * @access public     *    public function __construct($options = array())    {        $this->_options = $options;    }    */    /**     * Construct     * Gus     *     * @param string docxpresso_installation     * @param string $apikey     *     * @access public     */    public function __construct($docxpresso_installation, $apikey)    {        $this->_options = array();        $this->_options['pKey'] = $apikey;        $this->_options['docxpressoInstallation'] = $docxpresso_installation;    }    /**     * Setter for options     * @param array $options with the following keys and values     *      'pKey' => (string) the private key of your Docxpresso SERVER      *       installation     *      'docxpressoInstallation' => (string) the URL of your Docxpresso     *      SERVER installation     *      * @access public     */        public function setOptions($options)    {        $this->_options = $options;        return $this;    }        /**     * Checks the validity of an API key     *      * @param string $key the key you wish to validate     * @param string $data the string that was used to generate the key     * @param string $pKey the private key used to generate the hash     * @return boolean     * @access public     */    public function apikey_control($key, $data, $pKey)    {        $resultbin =  self::sha1_hmac($pKey , $data);        $result = bin2hex($resultbin);        if ($key == $result) {            return true;        } else {            return false;        }    }      /**     * Encodes in base64 url safe     *      * @param string $str     * @return string     * @access public     */    public function base64_encode_url_safe($str)    {        return strtr(base64_encode($str), '+/=', '-_,');    }      /**     * Decodes base64 url safe     *      * @param string $str     * @return string     * @access public     */    public function base64_decode_url_safe($str)    {        return base64_decode(strtr($str, '-_,', '+/='));    }        /**     * Generates a one time link to preview a document in the associated     * Docxpresso SERVER interface     *      * NOTE: if data is loaded from various sources it will be loaded with the      * folllowing priority: varData, requestDataURI, token     *      * @param array $data with the following keys and values     *      'template' => (int) the id of the requested document template.     *       This value is compulsory and must correspond to a valid template     *       id.     *      'token' => (string) a unique identifier of a previous use. If given     *       the data associated with the token will be preloaded into      *       the document.     *      'identifier' => (string) optional var name that we may pass to help      *       identify that particular usage. Default value is an empty string      *      'reference' => (string) an optional string we may pass to help      *       identify that particular usage. Default value is an empty string     *      'expires' => (integer) the number of seconds after which the link     *       is no longer valid.      *      'custom' => (string) an optional string we may pass to add external     *       additional info to the template      *       than an interactive document. Default value is false.     *      'form' => (boolean) if true Docxpresso will serve a web form rather     *       than an interactive document. Default value is false.     *      'format' => (string) the requested document output format. The     *       possible values include odt, pdf, doc, docx and rtf. If not given     *       the available formats will be taken from the template settings.     *      'enduserid' => (string) a value that will help us later to identify     *       the user that requested the document. Default value is an empty      *       string.     *      'requestConfigURI' => (string) the URL where Docxpresso should fetch     *       external configuration adjustments.     *      'requestDataURI' => (string) the URL where Docxpresso should fetch     *       external data. Default value is an empty string.     *      'requestExternalCSS' => (string) the URL where Docxpresso should     *       fetch for some external CSS file.     *      'requestExternalJS' => (string) the URL where Docxpresso should     *       fetch for some external JS file.     *      'responseDataURI' => (string) the URL where Docxpresso should     *       forward the user data. Default value is an empty string.     *      'responseURL' => (string) the URL where Docxpresso should redirect     *       the end user after saving the data. Default value is an empty      *       string.      *      'documentName' => (string) the name we want to give to the generated     *       document. Default value is an empty and in that case Docxpresso     *       will use the default template name.      *       string.     *      'domain' => (string) the URL doing the request. Default value is an      *       empty string.     *      'prefix' => (string) a prefix that will limit enduser edition to     *       only the field variables that start by that prefix. You can use     *       a comma separated list to select more than one prefix. Default value      *       is an empty string.     *      'editableVars' => (string) a comma separated list of var names     *       to restrict the edition to that set. Default value is an empty      *       string.     *      'enforceValidation' => (boolean) if true the user will not be able     *       to send data until all variable fields are validated. Default value     *       is false.     *      'language' => (string) if set will change the default interface     *       language. Currently available values are: default, en, es     *      'GDPR' => (boolean) if true the end user will be prompted to check     *       the privacy policy (it only applies if it is also globally defined)     *      'phone' => (string) with standard international format +12121112222.     *       If given the end user will be first prompted to introduce an OTP     *       sent to that phone.     *      'OTPmessage' => (string) this only applies if we use a phone to     *       request an OTP     *      'varData' => additional JSON data we would like to preload into the      *       document      * @return string     * @access public     */    public function previewDocument($data)    {             if (!empty($data['phone'])){            $url = $this->_options['docxpressoInstallation'] . '/tracking/OTP/request_OTP/' . $data['template'];        } else if(!empty($data['form']) && $data['form']){            $url = $this->_options['docxpressoInstallation'] . '/documents/previewForm/' . $data['template'];        }else {            $url = $this->_options['docxpressoInstallation'] . '/documents/preview/' . $data['template'];        }        $options = new \stdClass();        if(!empty($data['form']) && $data['form']){            $options->display = 'form';        }else {            $options->display = 'document';        }        if (!empty($data['phone'])){            $options->phone = $data['phone'];            $options->action = 'preview';        }        if (!empty($data['OTPmessage'])){            $options->OTPmessage = rawurlencode($data['OTPmessage']);        }        if (isset($data['token'])) {            $options->token = $data['token'];        }        if (isset($data['format'])) {            $options->forceFormat = $data['format'];        }         if (isset($data['enduserid'])) {            $options->enduserid = $data['enduserid'];        }         if (isset($data['identifier'])) {            $options->identifier = $data['identifier'];        }        if (isset($data['expires'])) {            $options->expires = $data['expires'];        }        if (isset($data['reference'])) {            $options->reference = $data['reference'];        }        if (isset($data['custom'])) {            $options->custom = $data['custom'];        }        if (!empty($data['requestConfigURI'])) {            $dURI = new \stdClass();            $dURI->URL = $data['requestConfigURI'];            $options->requestDataURI = json_encode($dURI);        }        if (!empty($data['requestDataURI'])) {            $dURI = new \stdClass();            $dURI->URL = $data['requestDataURI'];            $dURI->requestData = 'preview';            $options->requestDataURI = json_encode($dURI);        }        if (isset($data['requestExternalJS'])) {            $options->requestExternalJS = $data['requestExternalJS'];        }        if (isset($data['requestExternalCSS'])) {            $options->requestExternalCSS = $data['requestExternalCSS'];        }        if (!empty($data['responseDataURI'])) {            $options->responseDataURI = $data['responseDataURI'];        }        if (!empty($data['responseURL'])) {            $options->responseURL = $data['responseURL'];        }        if (!empty($data['documentName'])) {            $options->documentName = $data['documentName'];        }        if (!empty($data['domain'])) {            $options->domain = $data['domain'];        }        if (!empty($data['prefix'])) {            $options->prefix = $data['prefix'];        }         if (!empty($data['editableVars'])) {            $options->editableVars = $data['editableVars'];        }         if (!empty($data['enforceValidation'])) {            $options->enforceValidation = true;        }        if (!empty($data['GDPR'])) {            $options->GDPR = true;        }        if (!empty($data['language'])) {            $options->locale = $data['language'];        }        if (isset($data['varData'])) {            $options->data = $data['varData'];        }        $opt = $this->base64_encode_url_safe(json_encode($options));                return $this->_returnLink($url, $data['template'], $opt);        }        /**     * Generates a one time link to validate a document in the associated     * Docxpresso SERVER interface     *      * @param array $data with the following keys and values     *      'template' => (int) the id of the requested document template.     *       This value is compulsory and must correspond to a valid template     *       id.     *      'token' => (string) a unique identifier of a previous use. This      *       value is complusory and must correspond to a valid usage token.     *      'name' => (string) the name of the user that wll validate the      *       document. This value is compulsory      *      'email' => (string) the email of the user that wll validate the      *       document. This value is compulsory.     *      'language' => (string) if set will change the default interface     *       language. Currently available values are: default, en, es.     *      'responseDataURI' => (string) the URL where Docxpresso should     *       forward the user data. Default value is an empty string.     *      'responseURL' => (string) the URL where Docxpresso should redirect     *       the end user after validating the data. Default value is an empty      *       string.     *           * @return string     * @access public     */    public function validateDocument($data)    {             $url = $this->_options['docxpressoInstallation'] . '/documents/validate/preview/';        $url .= $data['template'] . '/' . $data['token'];        $options = new \stdClass();        if (isset($data['name'])) {            $options->name = $data['name'];        }        if (isset($data['email'])) {            $options->email = $data['email'];        }        if (isset($data['responseURL'])) {            $options->responseURL = $data['responseURL'];        }        if (!empty($data['responseDataURI'])) {            $options->responseDataURI = $data['responseDataURI'];        }        if (!empty($data['language'])) {            $options->locale = $data['language'];        }                $opt = $this->base64_encode_url_safe(json_encode($options));        //in this case we need to concatenate id and token so the apikey        //can not be reused for methods that allowed to use twice the        //apikey        $id = $data['template'] . $data['token'];        return $this->_returnLink($url, $id, $opt);        }        /**     * Returns a link to download all document validations in JSON(P)       * format  for a given template id from the associated Docxpresso      * SERVER installation     *      * @param array $data with the following keys and values     *      'id' => (int) the id of the template.     *       This value is compulsory and must correspond to a valid template     *       id.     *      'status' => (boolean) if true only acepted documents will be listed     *       and if false only rejected documents will be listed. Default value     *       is empty     *      'enduserid' => (string) the end user id of a particular revision.     *       Default value is empty.     *      'period' => (string) if given will overwrite the given startDate and     *       enddate parameters. The possible values are: today,      *       1week (last week), 1month (last month), 3month (last quarter),     *       year (last year). The default value is empty     *      'startDate' => (string) a date in the format yyyy-mm-dd that will     *       select usages that happened after it. Default value is an empty      *       string.     *      'endDate' => (string) a date in the format yyyy-mm-dd that will     *       select usages that happened before it. Default value is an empty      *       string.     *      'firstResult' => (int) query offset. Default value is 0;      *      'maxResults' => (int) maximum number of results. Beware that     *       each installation may have its own limits to this number     *      (usually 100)     *       Default value is empty and Docxpresso default will be used.     * @param string $callback the callback name that we want to use for padded     * JSON responses. If empty plain JSON will be returned.     * @return string     * @access public     */    public function validationsByTemplate($data, $callback = '')    {            $url = $this->_options['docxpressoInstallation']. '/RESTservices/predefined/validations_by_template/' . $data['id'];		        if (!empty($callback)) {                $url .= '/' . $callback;        }        //we build and options object with the search filters        $options = new \stdClass();        if (isset($data['status']) && $data['status']) {            $options->status = 1;        } else if (isset($data['status']) && !$data['status']) {            $options->status = 0;        } else {            $options->status = 2;        }        if (!empty($data['enduserid'])) {            $options->enduserid = $data['enduserid'];        }        //dates must be in the format 2016-01-30        if (!empty($data['startDate'])) {            $options->startDate = $data['startDate'];        }        if (!empty($data['endDate'])) {            $options->endDate = $data['endDate'];        }        if (!empty($data['period'])) {            $options->period = $data['period'];        }        if (!empty($data['firstResult'])) {            $options->firstResult = $data['firstResult'];        }        if (!empty($data['maxResults'])) {            $options->maxResults = $data['maxResults'];        }        if (!empty($data['sort'])) {            $options->sort = $data['sort'];        }        if (!empty($data['order'])) {            $options->order = $data['order'];        }        $opt = $this->base64_encode_url_safe(json_encode($options));		        return $this->_returnLink($url, $data['id'], $opt);    }        /**     * Generates a one time link to simply view a document within the     * Docxpresso interface with no action associated     *      * @param array $data with the following keys and values     *      'template' => (int) the id of the requested document template.     *       This value is compulsory and must correspond to a valid template     *       id.     *      'token' => (string) a unique identifier of a previous use. This      *       value is complusory and must correspond to a valid usage token.     *      'language' => (string) if set will change the default interface     *       language. Currently available values are: default, en, es.     *           * @return string     * @access public     */    public function viewDocument($data)    {             $url = $this->_options['docxpressoInstallation'] . '/documents/validate/view/';        $url .= $data['template'] . '/' . $data['token'];        $options = new \stdClass();        if (!empty($data['language'])) {            $options->locale = $data['language'];        }                $opt = $this->base64_encode_url_safe(json_encode($options));        //in this case we need to concatenate id and token so the apikey        //can not be reused for methods that allowed to use twice the        //apikey        $id = $data['template'] . $data['token'] . 'view';        return $this->_returnLink($url, $id, $opt);        }        /**     * Generates a one time link to regenerate a "full· document package" in zip     * format (document + attachments) from the associated     * Docxpresso SERVER installation     *      * @param array $data with the following keys and values     *      'id' => (int) the id of the corresponding template.     *       This value is compulsory and must correspond to a valid template     *       id.     *      'token' => (string) the token of the requested usage.     *      'identifier' => (string) if given the token will be ignored and     *       the returned document will be the last document retrieved with that     *       identifier.     *      'onlyDocument' => (boolean) if true only downloads the main document     *       ignoring any potential attachment. Default value false.     *      'documentName' => (string) the name we want to give to the generated     *       document (it should include the extensions: .odt, .pdf, .doc,      *       .doc(legacy), .docx or .rtf). The default values is document.odt     *      * @return string     * @access public     */    public function regenerateDocument($data)    {            $url = $this->_options['docxpressoInstallation']. '/documents/regenerateDocument/' . $data['id'];        $options = new \stdClass();        if (!empty($data['identifier'])){            $options->identifier = $data['identifier'];        } else {            $options->token = $data['token'];        }        if (isset($data['onlyDocument'])){            $options->onlyDocument = $data['onlyDocument'];        }        if (isset($data['documentName'])){            $options->documentName = $data['documentName'];        }        $opt = $this->base64_encode_url_safe(json_encode($options));               return $this->_returnLink($url, $data['id'], $opt);    }        /**     * Generates a one time link to generate a document in the associated     * Docxpresso SERVER interface     *      * NOTE: if data is loaded from various sources it will be loaded with the      * folllowing priority: varData, requestDataURI, token     *      * @param array $data with the following keys and values     *      'template' => (int) the id of the requested document template.     *       This value is compulsory and must correspond to a valid template     *       id.     *      'requestDataURI' => (string) the URL where Docxpresso should fetch     *       external data. Default value is an empty string.     *      'documentName' => (string) the name we want to give to the generated     *       document (it should include the extensions: .odt, .pdf, .doc,      *       .doc(legacy), .docx or .rtf). The default value is document.odt     *      'varData' => the JSON data we would like to use to generate the      *       document.     *      'token' => (string) a unique identifier of a previous use. If given     *       the data associated with the token will be preloaded into      *       the document.     *      'display' => (string) it can be 'document' (default) or 'form'.      *       This is only used for the generation of continue links     *      'response' => (string) it can be 'download'(default) if the document     *       is to be directly downloadable from the browser or 'json' if we want     *       to get the document as base64 encoded together with the usage id     *       and token     *      'callback' => it only spplies to json responses and sets the name     *       of the callback function for JSONP responses.     * @return string     * @access public     */    public function requestDocument($data)    {            $url = $this->_options['docxpressoInstallation'] . '/documents/requestDocument/' . $data['template'];	        $options = new \stdClass();        if (isset($data['documentName'])) {            $options->name = $data['documentName'];        } else {            $options->name = 'document.odt';        }        if (isset($data['varData'])) {            $options->data = $data['varData'];        } else {            $options->data = '{}';        }        if (isset($data['display'])) {            $options->display = $data['display'];        } else {            $options->display = 'document';        }        if (!empty($data['requestDataURI'])) {            $dURI = new \stdClass();            $dURI->URL = $data['requestDataURI'];            $options->requestDataURI = json_encode($dURI);        }        if (isset($data['token'])) {            $options->token = $data['token'];        }        $opt = $this->base64_encode_url_safe(json_encode($options));                return $this->_returnLink($url, $data['template'], $opt);        }        /**     * Generates a one time link to sign a document generated with Docxpresso     *      * @param array $data $data with the following keys and values     *      'usageId' => (int) the id of the corresponding usage.     *       This value is compulsory and must correspond to a valid document     *      'token' => (string) the token of the given usage for further     *       security.      *      'provider' => (string) it can be vidSigner, Lleida.net or NodalBlock     *      'signers' => (array) an array of arrays where the second array      *       includes the following key and values (some may be optional     *       depending on the provider and how the signature is parametrized):     *          'name': (string) signer's name     *          'id': (string) signer's id     *          'email': (string) signer's email     *          'phone': (string) signer's phone     *            * @return string     * @access public     */    public function requestSignature($data)    {        //TO BE DONE    }        /**     * Returns a link to download all document revisions in JSON(P)       * format  for a given template id from the associated Docxpresso      * SERVER installation     *      * @param array $data with the following keys and values     *      'id' => (int) the id of the template.     *       This value is compulsory and must correspond to a valid template     *       id.     *      'status' => (boolean) if true only acepted documents will be listed     *       and if false only rejected documents will be listed. Default value     *       is empty     *      'enduserid' => (string) the end user id of a particular revision.     *       Default value is empty.     *      'period' => (string) if given will overwrite the given startDate and     *       enddate parameters. The possible values are: today,      *       1week (last week), 1month (last month), 3month (last quarter),     *       year (last year). The default value is empty     *      'startDate' => (string) a date in the format yyyy-mm-dd that will     *       select usages that happened after it. Default value is an empty      *       string.     *      'endDate' => (string) a date in the format yyyy-mm-dd that will     *       select usages that happened before it. Default value is an empty      *       string.     *      'firstResult' => (int) query offset. Default value is 0;      *      'maxResults' => (int) maximum number of results. Beware that     *       each installation may have its own limits to this number     *      (usually 100)     *       Default value is empty and Docxpresso default will be used.     * @param string $callback the callback name that we want to use for padded     * JSON responses. If empty plain JSON will be returned.     * @return string     * @access public     */    public function revisionsByTemplate($data, $callback = '')    {            $url = $this->_options['docxpressoInstallation']. '/RESTservices/predefined/revisions_by_template/' . $data['id'];		        if (!empty($callback)) {                $url .= '/' . $callback;        }        //we build and options object with the search filters        $options = new \stdClass();        if (isset($data['status']) && $data['status']) {            $options->status = 1;        } else if (isset($data['status']) && !$data['status']) {            $options->status = 0;        } else {            $options->status = 2;        }        if (!empty($data['enduserid'])) {            $options->enduserid = $data['enduserid'];        }        //dates must be in the format 2016-01-30        if (!empty($data['startDate'])) {            $options->startDate = $data['startDate'];        }        if (!empty($data['endDate'])) {            $options->endDate = $data['endDate'];        }        if (!empty($data['period'])) {            $options->period = $data['period'];        }        if (!empty($data['firstResult'])) {            $options->firstResult = $data['firstResult'];        }        if (!empty($data['maxResults'])) {            $options->maxResults = $data['maxResults'];        }        if (!empty($data['sort'])) {            $options->sort = $data['sort'];        }        if (!empty($data['order'])) {            $options->order = $data['order'];        }        $opt = $this->base64_encode_url_safe(json_encode($options));		        return $this->_returnLink($url, $data['id'], $opt);    }        /**     * Generates a one time link to download an attachment from the associated     * Docxpresso SERVER installation     *      * @param array $data $data with the following keys and values     *      'usageId' => (int) the id of the corresponding usage.     *       This value is compulsory and must correspond to a valid template     *       id.     *      'name' => (string) the name of the attachment file we want to     *       download. It should correspond to the name given in the Docxpresso     *       SERVER processing interface.     *      'token' => (string) the token of the given usage for further     *       security.      * @return string     * @access public     */    public function downloadAttachment($data)    {            $url = $this->_options['docxpressoInstallation']. '/documents/getAttachment/' . $data['usageId'];        $uniqid = uniqid() . rand(99999, 9999999);        $timestamp = time();        $options = new \stdClass();        $options->name = $data['name'];        $options->token = $data['token'];	        $opt = $this->base64_encode_url_safe(json_encode($options));              return $this->_returnLink($url, $data['usageId'], $opt);         }        /**     * Generates a one time link to download a "full· document package" in zip     * format (document + attachments) from the associated     * Docxpresso SERVER installation     *      * @param array $data $data with the following keys and values     *      'id' => (int) the id of the corresponding template.     *       This value is compulsory and must correspond to a valid template     *       id.     *      'token' => (string) the token of the requested usage.     *      'identifier' => (string) if given the token will be ignored and     *       the returned docuemnt will be the last document retrieved with that     *       identifier.     *      'onlyDocument' => (boolean) if true only downloads the main document     *       ignoring any potential attachment. Default value false.     * @return string     * @access public     */    public function downloadDocument($data)    {            $url = $this->_options['docxpressoInstallation']. '/documents/getFullDocumentation/' . $data['id'];        $options = new \stdClass();        if (!empty($data['identifier'])){            $options->identifier = $data['identifier'];        } else {            $options->token = $data['token'];        }        if (isset($data['onlyDocument'])){            $options->onlyDocument = $data['onlyDocument'];        }        $opt = $this->base64_encode_url_safe(json_encode($options));               return $this->_returnLink($url, $data['id'], $opt);    }        /**     * Generates a one time link to get all annex document data: thumbnail,      * base64 encoded template odt file, etcetera.     *      * @param integer $token the token of the requested annex     * @param string $callback the callback name that we want to use for padded     * JSON responses. If empty plain JSON will be returned.     * @return string     * @access public     */    public function getAnnexData($token, $callback = '')    {            $url = $this->_options['docxpressoInstallation']. '/RESTservices/predefined/get_annex/' . $token;        if (!empty($callback)) {            $url .= '/' . $callback;        }		        return $this->_returnLink($url);    }        /**     * Generates a one time link to get all document template data: Docxpresso     *  data, thumbnail, base64 encoded template odt file, etcetera.     *      * @param integer $id the id of the required template     * @param string $callback the callback name that we want to use for padded     * JSON responses. If empty plain JSON will be returned.     * @return string     * @access public     */    public function getTemplateData($id, $callback = '')    {            $url = $this->_options['docxpressoInstallation']. '/RESTservices/predefined/get_template/' . $id;        if (!empty($callback)) {            $url .= '/' . $callback;        }		        return $this->_returnLink($url, $id);    }        /**     * Generates a one time link to get just a template thumbnail     *      * @param integer $id the id of the required template     * @param string $callback the callback name that we want to use for padded     * JSON responses. If empty plain JSON will be returned.     * @return string     * @access public     */    public function getTemplateThumbnail($id, $callback = '')    {            $url = $this->_options['docxpressoInstallation']. '/RESTservices/predefined/get_thumbnail/' . $id;        if (!empty($callback)) {            $url .= '/' . $callback;        }		        return $this->_returnLink($url, $id);    }        /**     * Get current usage for administrative purposes     *      * @param string $callback the callback name that we want to use for padded     * JSON responses. If empty plain JSON will be returned.     * @return array     * @access public     */    public function getUsageCurrent($callback = '')    {            $url = $this->_options['docxpressoInstallation']. '/RESTservices/predefined/get_usage_current';        if (!empty($callback)) {            $url .= '/' . $callback;        }		        return $this->_returnLink($url);    }            /**     * Get usage history by year/month for administrative purposes     *      * @param string $callback the callback name that we want to use for padded     * JSON responses. If empty plain JSON will be returned.     * @return string     * @access public     */    public function getUsageHistory($callback = '')    {            $url = $this->_options['docxpressoInstallation']. '/RESTservices/predefined/get_usage_history';        if (!empty($callback)) {            $url .= '/' . $callback;        }		        return $this->_returnLink($url);    }        /**     * Modifies the template configuration: variables and groups.      * WARNING: beware that in order to modify the group properties you need     * to know the group ids that can be retrieved with the getTemplateData     * method or generated as follows: in order to generate the id one need to     * know the name of all variables inclued in the group and generate the     * md5 hash obtained from concatening with commas all those variables     * following their order of appearance in the corresponding template.     * For example, the group id of a table with two variables named product and     * price will be md5('product,price')     *      * @param array data an array of arrays with the folowing key values:     *      'id': the id of the required template     *      'settings': an array of arrays with the following key value pairs:     *         'numberFormat': can bw ".;" or ",."     *         'outputComments' (boolean)     *         'outputFormat': an array with the possible, non-exclusive, values     *          ["odt", "pdf", "doc", "docx", "doc-legacy", "rtf"]     *     'variables': an array of arrays with the following key value pairs:     *         'variable name': an array with the following key value pairs:     *             'scope': can be document, form or both (default value)     *             'label' (text)     *             'tip' (text)     *             'comment' (HTML text)     *             'type': it can be text, options, date or phone.     *             'richtext' (boolean) only applies if the type is text.     *             'choice': dropdown, checkbox or radio. Only applies if the     *               type is options.     *             'options': ";" separated list of values. Only applies if the     *              type takes the "options" value     *             'compulsory'(boolean)     *             'editable' (boolean)     *             'global' (boolean)     *             'confirm' (boolean)     *             'validation' (string) validation name (only relevant to     *              identify the validation in the web edition interface)     *             'regex': regular expression used to validate this field     *     'groups': an array of arrays with the following key value pairs:     *          'group id': an array with the following key value pairs:     *             'active' (boolean) if true (default value) this group     *              is clonable     *             'display': can be show (default) or hide     *             'print': can be print (default), unprint (only visible in     *              the browser) or unbrowsable (only printed and not visible     *              in the browser)     *             'toggleWith' (text)     *             'toggleValues' (text)     *       * @param string $callback the callback name that we want to use for padded     * JSON responses. If empty plain JSON will be returned.     * @return string     * @access public     */    public function modifyTemplateData($data, $callback = '')    {            $url = $this->_options['docxpressoInstallation']. '/RESTservices/predefined/modify_template/' . $data['id'];        if (!empty($callback)) {            $url .= '/' . $callback;        }                $options = new \stdClass();        $options->id = $data['id'];        if (isset($data['settings'])){            $options->settings = $data['settings'];        } else {            $options->settings = new \stdClass();        }        if (isset($data['variables'])){            $options->variables = $data['variables'];        } else {            $options->variables = new \stdClass();        }        if (isset($data['groups'])){            $options->groups = $data['groups'];        } else {            $options->groups = new \stdClass();        }		        $opt = $this->base64_encode_url_safe(json_encode($options));               return $this->_returnLink($url, $data['id'], $opt);    }        /**     * Allows to remotely authenticate from any other application into the     * associated Docxpresso SERVER installation     *      * @param array $data $data with the following keys and values     *      'email' => (string) the email of the user we want to log in.     *       This value is compulsory and must correspond to a valid registered     *       user email.     *      'url' => (string) target url where the user should be redirected     *       after being authenticated     *      'referer' => (string) domain origin of the petition     * @return string     * @access public     */    public function accessByTokenAction($data)    {            $url = $this->_options['docxpressoInstallation']. '/users/accessByToken';        $options = new \stdClass();        $options->email = $data['email'];        $options->url = $data['url'];        $options->referer = $data['referer'];        $opt = $this->base64_encode_url_safe(json_encode($options));              return $this->_returnLink($url, NULL, $opt);         }        /**     * Allows to remotely create an user     *      * @param array $data $data with the following keys and values     *      'username' => (string) alias to be used within Docxpresso.     *       This value is compulsory and can not coincide with the username      *       of an already registered user.     *      'email' => (string) the email of the user we want to create.     *       This value is compulsory and can not coincide with the email of an     *      'password' => (string) the password of the user we want to create.     *       This value is compulsory and must be safe.     *      'name' => (string) full user name (compulsory)     *      'role' => (string) it must take one of the following values: admin,     *       editor, user, external. Default value is user.     *      'position' => (string) user position (optional)     *      'phone' => (string) user phone (optional)     *      'description' => (string) short user description (optional)     * @return string     * @access public     */    public function createUser($data)    {            $url = $this->_options['docxpressoInstallation']. '/users/createRemoteUser';        $options = new \stdClass();        $options->email = $data['email'];        $options->username = $data['username'];        $options->password = $data['password'];        $options->name = $data['name'];        if ($data['role'] == "admin"){            $options->role = 3;        } else if ($data['role'] == "editor"){            $options->role = 2;        } else if ($data['role'] == "user"){            $options->role = 1;        } else if ($data['role'] == "external"){            $options->role = 0;        }        if (isset($data['position'])){            $options->position = $data['position'];        } else {            $options->position = " ";        }        if (isset($data['phone'])){            $options->phone = $data['phone'];        } else {            $options->phone = " ";        }        if (isset($data['description'])){            $options->description = $data['description'];        } else {            $options->description = " ";        }        $opt = $this->base64_encode_url_safe(json_encode($options));              return $this->_returnLink($url, NULL, $opt);         }        /**     * Create a workflow     *      * @param array $data with the following keys and values     *      'template' => (int) the id of the requested document template.     *       This value is compulsory and must correspond to a valid template     *       id.     *      'description' => (string) short (HTML) description of the workflow     *       to be used in automated emails.     *      'token' => (string) a unique identifier of a previous use. If given     *       the data associated with the token will be preloaded into      *       the document. The default value is NULL.     *      'ordered' => (boolean) if true (default value) the workflow will be     *       an ordered workflow.     *      'display' => (string) it can be 'document' (default) or 'form'.     *      'steps' => (array) the steps should be an array of arrays each of      *       them with the following keys and values:     *          'username' => (string) the name of the user associated with that     *           step.     *          'useremail' => (string) the email of the user associated with     *           that step.     *          'action' => (string) the associated action. It can take the     *           following values: 'edit' (default value) or 'validate'.     *          'rejectionAction' => (string) the action to be taken if a      *           validation is rejected. It can take the following values:     *           'stepBack' (default value) or 'complete'.     *          'notify' => (boolean) if true (default value) the user will be     *           notified by email.     *          'send' => (boolean) if true (default value) the user will     *           receive a copy of the document upon completion of the workflow.     *          'prefix' => (string) a prefix that will limit enduser edition to     *           only the field variables that start by that prefix. You can use     *           a comma separated list to select more than one prefix. Default      *           value is an empty string.     *          'editableVars' => (string) a comma separated list of var names     *           to restrict the edition to that set. Default value is an empty      *           string.     *          * @return string     * @access public     */    public function createWorkflow($data, $callback = '')    {            $url = $this->_options['docxpressoInstallation']. '/documents/workflow/create_remote_workflow/' . $data['template'];        if (!empty($callback)) {            $url .= '/' . $callback;        }        $options = new \stdClass();        if (isset($data['token'])) {            $options->token = $data['token'];        }        if (isset($data['display'])) {            $options->display = $data['display'];        }        $workflow = new \stdClass();	if (isset($data['ordered']) && !$data['ordered']) {            $workflow->ordered = 0;        } else {            $workflow->ordered = 1;        }        if (isset($data['description'])) {            $workflow->description = $data['description'];        } else {            $workflow->description = '';        }        //workflow steps        $workflow->steps = array();        $numSteps = count($data['steps']);        for ($j = 0; $j < $numSteps; $j++){            $workflow->steps[$j] = new \stdClass();            $workflow->steps[$j]->completed = 0;            if (isset($data['steps'][$j]['notify']) && !$data['steps'][$j]['notify']) {                $workflow->steps[$j]->notify = 0;            } else {                $workflow->steps[$j]->notify = 1;            }            if (isset($data['steps'][$j]['send']) && !$data['steps'][$j]['send']) {                $workflow->steps[$j]->send = 0;            } else {                $workflow->steps[$j]->send = 1;            }            if (isset($data['steps'][$j]['action']) && $data['steps'][$j]['action'] == 'validate') {                $workflow->steps[$j]->actionType = 'validate';            } else {                $workflow->steps[$j]->actionType = 'edit';            }            if (isset($data['steps'][$j]['rejectionAction']) && $data['steps'][$j]['rejectionAction'] == 'complete') {                $workflow->steps[$j]->rejectionAction = 'completedWF';            } else {                $workflow->steps[$j]->rejectionAction = 'stepBack';            }            if (isset($data['steps'][$j]['prefix'])) {                $workflow->steps[$j]->prefix = $data['steps'][$j]['prefix'];            } else {                $workflow->steps[$j]->prefix = '';            }            if (isset($data['steps'][$j]['editableVars'])) {                $workflow->steps[$j]->editableVars = $data['steps'][$j]['editableVars'];            } else {                $workflow->steps[$j]->editableVars = '';            }            $workflow->steps[$j]->useremail = $data['steps'][$j]['useremail'];            $workflow->steps[$j]->username = $data['steps'][$j]['username'];        }        $options->workflow = $workflow;        $opt = $this->base64_encode_url_safe(json_encode($options));                return $this->_returnLink($url, $data['template'], $opt);      }        /**     * Returns a link to list of categories in JSON(P) format from the associated     * Docxpresso SERVER installation     *      * @param string $callback the callback name that we want to use for padded     * JSON responses. If empty plain JSON will be returned.     * @return string     * @access public     */    public function listCategories($callback = '')    {            $url = $this->_options['docxpressoInstallation']. '/RESTservices/predefined/categories';                if (!empty($callback)) {            $url .= '/' . $callback;        }               return $this->_returnLink($url);    }        /**     * Returns a link to list of documents in a given category in JSON(P) format     * from the associated Docxpresso SERVER installation     *      * @param integer $category the corresponding category id.     * @param string $callback the callback name that we want to use for padded     * JSON responses. If empty plain JSON will be returned.     * @param boolean $published if true only "published" templates will be     * available through the request.     * @param string $access it can be "all" (deafult value), "public" for only     * documents declared like public or a "username" to filter by permissions     * @return string     * @access public     */    public function documentsByCategory($category, $callback = '', $published = 0, $access = 'all')    {            $url = $this->_options['docxpressoInstallation']. '/RESTservices/predefined/documents_by_category/' . $category;        if (!empty($callback)) {            $url .= '/' . $callback;        } else {            $url .= '/NULL';        }        if (!empty($published)) {            $url .= '/1';        } else {            $url .= '/0';        }                if (!empty($access)) {            $url .= '/' . rawurlencode($access);        }		        return $this->_returnLink($url);    }        /**     * Allows to change the password associated with a user email.     *      * @param string $email user unique email identifier.     * @param string $password new password. It should be, at least 12 chars long     * and contain at least an uppercase letter, a lowercase letter, a number     * and a non-standard char: !,%,&,@,#,$,^,*,?,_,~     * @param boolean $notify set it to true (default value) if you want to     * the user of the password change     * @param string $callback the callback name that we want to use for padded     * JSON responses. If empty plain JSON will be returned.     * @return string     * @access public     */    public function modifyPassword($email, $password, $notify = true, $callback = '')    {            $url = $this->_options['docxpressoInstallation']. '/RESTservices/predefined/modify_password';        if (!empty($callback)) {            $url .= '/' . $callback;        }	$options = new \stdClass();        $options->email = $email;        $options->password = $password;        $options->notify = $notify;        $opt = $this->base64_encode_url_safe(json_encode($options));        return $this->_returnLink($url, NULL, $opt);    }        /**     * Allows to modify the configuration of Signature Providers. If the     * requested signature provider does not exist and it belongs to one of     * the current available ones the corresponding entry will be created.     *      * @param string $provider the name of the signature provider. Currently     * the only available ones are vidSigner, lleida.net or nodalblock     * @param string $config base64 encoded config JSON.     * @param string $callback the callback name that we want to use for padded     * JSON responses. If empty plain JSON will be returned.     * @return string     * @access public     */    public function modifySignatureProvider($provider, $config, $callback = '')    {            $url = $this->_options['docxpressoInstallation']. '/RESTservices/predefined/modify_signature_providers/' . $provider;        if (!empty($callback)) {            $url .= '/' . $callback;        }	$options = new \stdClass();        $options->custom = $config;        $opt = $this->base64_encode_url_safe(json_encode($options));        return $this->_returnLink($url, NULL, $opt);    }        /**     * Allows to delete a current signature provider.     *      * @param string $provider the name of the signature provider. Currently     * the only available one is vidSigner     * @param string $callback the callback name that we want to use for padded     * JSON responses. If empty plain JSON will be returned.     * @param boolean $published if true only "published" templates will be     * available through the request.     * @return string     * @access public     */    public function deleteSignatureProvider($provider, $callback = '')    {            $url = $this->_options['docxpressoInstallation']. '/RESTservices/predefined/delete_signature_providers/' . $provider;        return $this->_returnLink($url);    }        /**     * List all Signature Providers     *      * @param string $callback the callback name that we want to use for padded     * JSON responses. If empty plain JSON will be returned.     * @param boolean $published if true only "published" templates will be     * available through the request.     * @return string     * @access public     */    public function listSignatureProviders($callback = '')    {            $url = $this->_options['docxpressoInstallation']. '/RESTservices/predefined/list_signature_providers';        if (!empty($callback)) {            $url .= '/' . $callback;        }		        return $this->_returnLink($url);    }        /**     * Returns a link to download the whole document (sub)tree in JSON(P) format       * from the associated Docxpresso SERVER installation     *      * @param mixed $rootCategory the corresponding category id from which     * we want to build the document tree. Default value is 'root' that corresponds     * with the "root category"     * @param string $callback the callback name that we want to use for padded     * JSON responses. If empty plain JSON will be returned.     * @param boolean $published if true only "published" templates will be     * available through the request.     * @param string $access it can be "all" (deafult value), "public" for only     * documents declared like public or a "username" to filter by permissions     * @return string     * @access public     */    public function documentTree($rootCategory= 'root', $callback = '', $published = 0, $access = 'all')    {            if ($rootCategory == 'root') {            $rootCategory = 1;        }                $url = $this->_options['docxpressoInstallation']. '/RESTservices/predefined/document_tree/' . $rootCategory;        if (!empty($callback)) {            $url .= '/' . $callback;        } else {            $url .= '/NULL';        }        if (!empty($published)) {            $url .= '/1';        } else {            $url .= '/0';        }                if (!empty($access)) {            $url .= '/' . rawurlencode($access);        }        return $this->_returnLink($url);    }        /**     * Returns a link to download the whole category (sub)tree in JSON(P) format       * from the associated Docxpresso SERVER installation. If you need to include     * documents use the documentTree method instead.     *      * @param mixed $rootCategory the corresponding category id from which     * we want to build the document tree. Default value is 'root' that corresponds     * with the "root category"     * @param string $callback the callback name that we want to use for padded     * JSON responses. If empty plain JSON will be returned.     * @return string     * @access public     */    public function categoryTree($rootCategory= 'root', $callback = '')    {            if ($rootCategory == 'root') {            $rootCategory = 1;        }                $url = $this->_options['docxpressoInstallation']. '/RESTservices/predefined/category_tree/' . $rootCategory;        if (!empty($callback)) {            $url .= '/' . $callback;        } else {            $url .= '/NULL';        }        return $this->_returnLink($url);    }        /**     * Returns a link to download all documents with a given name in JSON(P)       * format from the associated Docxpresso SERVER installation     *      * @param string $name the name of the template we are looking for. This     * method launches a "LIKE" SQL query.     * @param string $callback the callback name that we want to use for padded     * JSON responses. If empty plain JSON will be returned.     * @param boolean $published if true only "published" templates will be     * available through the request.     * @param string $access it can be "all" (deafult value), "public" for only     * documents declared like public or a "username" to filter by permissions     * @return string     * @access public     */    public function templatesByName($name, $callback = '', $published = 0, $access = "all")    {            $url = $this->_options['docxpressoInstallation'];        $url .= '/RESTservices/predefined/documents_by_name/' . rawurlencode($name);        if (!empty($callback)) {            $url .= '/' . $callback;        } else {            $url .= '/NULL';        }        if (!empty($published)) {            $url .= '/1';        } else {            $url .= '/0';        }                if (!empty($access)) {            $url .= '/' . rawurlencode($access);        }        return $this->_returnLink($url);    }        /**     * Returns a link to download the info (thumbnail included) of the most     * recently edited templates     *      * @param string $limit the number of templates we want to retrieve.     * @param string $callback the callback name that we want to use for padded     * JSON responses. If empty plain JSON will be returned.     * @param boolean $published if true only "published" templates will be     * available through the request.     * @return string     * @access public     */    public function latestTemplates($limit, $callback = '', $published = 0)    {            $url = $this->_options['docxpressoInstallation'];        $url .= '/RESTservices/predefined/latest_templates/' . $limit;        if (!empty($callback)) {            $url .= '/' . $callback;        } else {            $url .= '/NULL';        }        if (!empty($published)) {            $url .= '/1';        } else {            $url .= '/0';        }        return $this->_returnLink($url);    }        /**     * Returns a link to list all documents with a given name and/or a        * given category from the associated Docxpresso SERVER installation     *      * @param integer $page the page we want to retrieve     * @param array $data with the following keys and values     *      'name' => (string) the name we want to filter the results with a      *       LIKE%% clause. This parameter is optional.     *      'category' => (integer) the category we want to filter by if any.     *       Subcategories are not included.     *      'numResults' => (int) number of results per page. This number can      *       not be bigger than 100 and it defaults to 20.     *      'sort' => (string) the field used to sort the results.     *      'order' => (string) possible values are DESC (default) or ASC.     * @param string $callback the callback name that we want to use for padded     * JSON responses. If empty plain JSON will be returned.     * @return string     * @access public     */    public function listTemplatesPaginated($page, $data = array(), $callback = '')    {            $url = $this->_options['docxpressoInstallation'];        $url .= '/RESTservices/predefined/list_templates_paginated/' . $page;        if (!empty($callback)) {            $url .= '/' . $callback;        }                //we build and options object with the search filters        $options = new \stdClass();        if (!empty($data['name'])) {            $options->identifier = $data['name'];        }        if (!empty($data['numResults'])) {            $options->numResults = $data['numResults'];        }        if (!empty($data['category'])) {            $options->category = $data['category'];        }        if (!empty($data['sort'])) {            $options->sort = $data['sort'];        }        if (!empty($data['order'])) {            $options->order = $data['order'];        }                $opt = $this->base64_encode_url_safe(json_encode($options));        return $this->_returnLink($url, NULL, $opt);    }        /**     * Returns a link to download the data of a given single usage JSON(P)       * format from the associated Docxpresso SERVER installation     *      * @param integer $limit the max numbers of uses to be downloaded. This     * parameter is compulsory. If bigger then the max allowed limit the number     * of results will be truncated.     * @param string $callback the callback name that we want to use for padded     * JSON responses. If empty plain JSON will be returned.     * @return string     * @access public     */    public function lastUsages($limit, $callback = '')    {            $url = $this->_options['docxpressoInstallation']. '/RESTservices/predefined/last_usages/' . $limit;        if (!empty($callback)) {            $url .= '/' . $callback;        }		        return $this->_returnLink($url);    }        /**     * Returns a list of the lestest used templates     *      * @param integer $limit the max numbers of uses to be downloaded. This     * parameter is compulsory. If bigger then the max allowed limit the number     * of results will be truncated. Default number is 10.     * @param string $callback the callback name that we want to use for padded     * JSON responses. If empty plain JSON will be returned.     * @return string     * @access public     */    public function lastUsedTemplates($limit = 10, $callback = '')    {            $url = $this->_options['docxpressoInstallation']. '/RESTservices/predefined/last_used_templates/' . $limit;        if (!empty($callback)) {            $url .= '/' . $callback;        }		        return $this->_returnLink($url);    }	    /**     * Returns a link to download all template usage data in JSON(P)       * format  for a given template id from the associated Docxpresso      * SERVER installation     *      * @param array $data with the following keys and values     *      'id' => (int) the id of the template.     *       This value is compulsory and must correspond to a valid template     *       id.     *      'identifier' => (string) the identifier field of an usage. The     *       default value is an empty string     *      'reference' => (string) the reference field of an usage. The     *       default value is an empty string     *      'enduserid' => (string) the end user id of a particular usage.     *       Default value is an empty string.     *      'period' => (string) if given will overwrite the given startDate and     *       enddate parameters. The possible values are: today,      *       1week (last week), 1month (last month), 3month (last quarter),     *       year (last year). The default value is empty     *      'startDate' => (string) a date in the format yyyy-mm-dd that will     *       select usages that happened after it. Default value is an empty      *       string.     *      'endDate' => (string) a date in the format yyyy-mm-dd that will     *       select usages that happened before it. Default value is an empty      *       string.     *      'locked' => (integer) it can be zero for all usages (default), 1 if     *       we only want usages that have been set as completed or 2 for the      *       opposite.     *      'firstResult' => (int) query offset. Default value is 0;      *      'maxResults' => (int) maximum number of results. Beware that     *       each installation may have upper limits to this number.     *       Default value is empty and Docxpresso default will be used (50).     *      'sort' => (string) the field used to sort the results.     *      'order' => (string) possible values are DESC (default) or ASC.     * @param string $callback the callback name that we want to use for padded     * JSON responses. If empty plain JSON will be returned.     * @return string     * @access public     */    public function dataByTemplate($data, $callback = '')    {            $url = $this->_options['docxpressoInstallation']. '/RESTservices/predefined/data_by_template/' . $data['id'];		        if (!empty($callback)) {                $url .= '/' . $callback;        }        //we build and options object with the search filters        $options = new \stdClass();        if (!empty($data['identifier'])) {            $options->identifier = $data['identifier'];        }        if (!empty($data['reference'])) {            $options->reference = $data['reference'];        }        if (!empty($data['enduserid'])) {            $options->enduserid = $data['enduserid'];        }        if (!empty($data['locked'])) {            $options->locked = $data['locked'];        }        //dates must be in the format 2016-01-30        if (!empty($data['startDate'])) {            $options->startDate = $data['startDate'];        }        if (!empty($data['endDate'])) {            $options->endDate = $data['endDate'];        }        if (!empty($data['period'])) {            $options->period = $data['period'];        }        if (!empty($data['firstResult'])) {            $options->firstResult = $data['firstResult'];        }        if (!empty($data['maxResults'])) {            $options->maxResults = $data['maxResults'];        }        if (!empty($data['sort'])) {            $options->sort = $data['sort'];        }        if (!empty($data['order'])) {            $options->order = $data['order'];        }        $opt = $this->base64_encode_url_safe(json_encode($options));		        return $this->_returnLink($url, $data['id'], $opt);    }        /**     * Returns a link to download the 'paginated' template usage data in JSON(P)       * format  for a given template id from the associated Docxpresso      * SERVER installation     *      * @param integer $page the page we want to retrieve     * @param array $data with the following keys and values     *      'id' => (int) the id of the template.     *       This value is compulsory and must correspond to a valid template     *       id.     *      'identifier' => (string) the identifier field of an usage. The     *       default value is an empty string     *      'reference' => (string) the reference field of an usage. The     *       default value is an empty string     *      'enduserid' => (string) the end user id of a particular usage.     *       Default value is an empty string.     *      'period' => (string) if given will overwrite the given startDate and     *       enddate parameters. The possible values are: today,      *       1week (last week), 1month (last month), 3month (last quarter),     *       year (last year). The default value is empty     *      'startDate' => (string) a date in the format yyyy-mm-dd that will     *       select usages that happened after it. Default value is an empty      *       string.     *      'endDate' => (string) a date in the format yyyy-mm-dd that will     *       select usages that happened before it. Default value is an empty      *       string.     *      'locked' => (integer) it can be zero for all usages (default), 1 if     *       we only want usages that have been set as completed or 2 for the      *       opposite.     *      'numResults' => (int) number of results per page. This number can      *       not be bigger than 100 and it defaults to 20.     *      'sort' => (string) the field used to sort the results.     *      'order' => (string) possible values are DESC (default) or ASC.     * @param string $callback the callback name that we want to use for padded     * JSON responses. If empty plain JSON will be returned.     * @return string     * @access public     */    public function dataByTemplatePaginated($page, $data, $callback = '')    {            $url = $this->_options['docxpressoInstallation']. '/RESTservices/predefined/data_by_template_paginated/' . $data['id'] . '/' . $page;		        if (!empty($callback)) {                $url .= '/' . $callback;        }        //we build and options object with the search filters        $options = new \stdClass();        if (!empty($data['identifier'])) {            $options->identifier = $data['identifier'];        }        if (!empty($data['reference'])) {            $options->reference = $data['reference'];        }        if (!empty($data['enduserid'])) {            $options->enduserid = $data['enduserid'];        }        if (!empty($data['locked'])) {            $options->locked = $data['locked'];        }        //dates must be in the format 2016-01-30        if (!empty($data['startDate'])) {            $options->startDate = $data['startDate'];        }        if (!empty($data['endDate'])) {            $options->endDate = $data['endDate'];        }        if (!empty($data['period'])){            $options->period = $data['period'];        }        if (!empty($data['numResults'])) {            $options->numResults = $data['numResults'];        }        if (!empty($data['sort'])) {            $options->sort = $data['sort'];        }        if (!empty($data['order'])) {            $options->order = $data['order'];        }        $opt = $this->base64_encode_url_safe(json_encode($options));		        return $this->_returnLink($url, $data['id'], $opt);    }        /**     * Returns a link to download the data of a given single usage JSON(P)       * format from the associated Docxpresso SERVER installation     *      * @param integer $usageId the id of a particular usage     * @param string $callback the callback name that we want to use for padded     * JSON responses. If empty plain JSON will be returned.     * @return string     * @access public     */    public function dataByUsage($usageId, $callback = '')    {            $url = $this->_options['docxpressoInstallation']. '/RESTservices/predefined/data_by_usage/' . $usageId;        if (!empty($callback)) {            $url .= '/' . $callback;        }		        return $this->_returnLink($url, $usageId);    }        /**     * Returns a link to generate a HTML or CSV file for all the data usage     * for a given template       *      * @param array $data with the following keys and values     *      'id' => (int) the id of the template. This value is compulsory and      *       must correspond to a valid template id.     *      'format' => (string) it may be html or csv (default)     *      'identifier' => (string) the identifier field of an usage. The     *       default value is an empty string     *      'reference' => (string) the reference field of an usage. The     *       default value is an empty string     *      'enduserid' => (string) the end user id of a particular usage.     *       Default value is an empty string.     *      'idrange' => (string) the range of ids that should be filtered, i.e.     *       120-145. Default value is an empty string.     *      'period' => (string) if given will overwrite the given startDate and     *       enddate parameters. The possible values are: today,      *       1week (last week), 1month (last month), 3month (last quarter),     *       year (last year). The default value is empty     *      'startDate' => (string) a date in the format yyyy-mm-dd that will     *       select usages that happened after it. Default value is an empty      *       string.     *      'endDate' => (string) a date in the format yyyy-mm-dd that will     *       select usages that happened before it. Default value is an empty      *       string.     *      'locked' => (integer) it can be zero for all usages (default), 1 if     *       we only want usages that have been set as completed or 2 for the      *       opposite.     *      'firstResult' => (int) query offset. Default value is 0;      *      'maxResults' => (int) maximum number of results. Beware that     *       each installation may have upper limits to this number.     *       Default value is an empty and in that case Docxpresso     *      'sort' => (string) the field used to sort the results.     *      'order' => (string) possible values are DESC (default) or ASC.     * @return string     * @access public     */    public function dataDigestByUsage($data)    {            $url = $this->_options['docxpressoInstallation']. '/data/digest/' . $data['id'] ;        $url = $this->_returnLink($url, $data['id'], NULL) . '&';        //we build the URL with the search filters and output foemat        if (!empty($data['format'])) {            $url .= 'format=' . $data['format'] . '&';        } else {            $url .= 'format=csv&';        }        if (!empty($data['identifier'])) {            $url .= 'identifier=' . $data['identifier'] . '&';        }        if (!empty($data['reference'])) {            $url .= 'reference=' . $data['reference'] . '&';        }        if (!empty($data['enduserid'])) {            $url .= 'enduserid=' . $data['enduserid'] . '&';        }        //dates like before and after must be in the format 2016-01-30        if (!empty($data['startDate'])) {            $url .= 'before=' . $data['startDate'] . '&';        }        if (!empty($data['endDate'])) {            $url .= 'after=' . $data['endDate'] . '&';        }        if (!empty($data['period'])) {            $url .= 'period=' . $data['period'] . '&';        }        if (!empty($data['domain'])) {            $url .= 'domain=' . $data['domain'] . '&';        }        if (!empty($data['idrange'])) {            $url .= 'idrange=' . $data['idrange'] . '&';        }        if (!empty($data['locked'])) {            $url .= 'locked=' . $data['locked'] . '&';        }        if (!empty($data['maxResults'])) {            $url .= 'maxResults=' . $data['maxResults'] . '&';        }        if (!empty($data['sort'])) {            $url .= 'sort=' . $data['sort'] . '&';        }        if (!empty($data['order'])) {            $url .= 'order=' . $data['order'];        }        return $url;    }        /**     * Returns a link to modify the data and options of a particular usage.     * In order to avoid unwanted/accidental changes of data we request together     * with the usageId its unique assocated token     *      *      * @param integer $usageId the id of a particular usage     * @param array $data with the following keys and values     *      'token' => (string) the unique identifier of this use. This is     *       only required for security to avoid unintentional changes in the      *       usage data.     *      'identifier' => (string) the identifier value that we want to     *       overwrite. Default value is an empty string      *      'reference' => (string) the reference value that we want to     *       overwrite. Default value is an empty string      *      'validated' => (boolean) an optional boolean parameter to overwrite     *       the previous value.     *      'tampered' => (boolean) an optional boolean parameter to overwrite     *       the previous value.     *      'locked' => (boolean) an optional boolean parameter to overwrite     *       the previous value. It is also may be interpreted as "completed"     *      'comments' => (string) if not empty it will overwrite the comments     *       associated with this usage. Default value is an empty      *       string.     *      'percentageCompleted' => (integer) if given  overwrites the value of     *       the percentage completed.      *       string.     *      'varData' => JSON data that will be merged with the previous stored     *       document data (by the time being only variable values).     * @return string     * @access public     */    public function modifyUsageData($usageId, $data)    {            $url = $this->_options['docxpressoInstallation']. '/RESTservices/predefined/modify_usage_data/' . $usageId;                $options = new \stdClass();        if (isset($data['token'])) {            $options->token = $data['token'];        }        if (isset($data['identifier'])) {            $options->identifier = $data['identifier'];        }        if (isset($data['reference'])) {            $options->reference = $data['reference'];        }        if (isset($data['tampered']) && $data['tampered']) {            $options->tampered = 1;        } else if (isset($data['tampered']) && !$data['tampered']) {            $options->tampered = 0;        }        if (isset($data['validated']) && $data['validated']) {            $options->validated = 1;        } else if (isset($data['validated']) && !$data['validated']) {            $options->validated = 0;        }         if (!empty($data['locked']) && $data['locked']) {            $options->locked = 1;        } else if (isset($data['locked']) && !$data['locked']) {            $options->validated = 0;        }        if (!empty($data['comments'])) {            $options->comments = $data['comments'];        }        if (isset($data['varData'])) {            $options->data = $data['varData'];        }        	$opt = $this->base64_encode_url_safe(json_encode($options));	        return $this->_returnLink($url, $usageId, $opt);    }        /**     * Returns a link to get a JSON with both the document base64 encoded      * together with the other usage data      *      * @param integer $usageId the id of a particular usage     * @param string $callback the callback name that we want to use for padded     * JSON responses. If empty plain JSON will be returned.     * @return string     * @access public     */    public function documentAndDataByUsage($usageId, $callback = '')    {            $url = $this->_options['docxpressoInstallation']. '/RESTservices/predefined/document_and_data_by_usage/' . $usageId;        if (!empty($callback)) {            $url .= '/' . $callback;        }		        return $this->_returnLink($url, $usageId);    }        /**     * Returns a link to download basic statistical data like number of uses     * and last usage     *      * @param mixed $id template id. If set to 'all' the data     * for all available templates will be provided     * @param string $callback the callback name that we want to use for padded     * JSON responses. If empty or NULL plain JSON will be returned.     * @param boolean $published if true only "published" templates will be     * available through the request.     * @return string     * @access public     */        public function dataStatistics($id = 'all', $callback = '', $published = 0)    {            $url = $this->_options['docxpressoInstallation']. '/RESTservices/predefined/data_statistics';		        if (!empty($id)) {            $url .= '/' . $id;        } else {            $url .= '/all';        }		        if (!empty($callback)) {            $url .= '/' . $callback;        } else if (!empty($published)) {            $url .= '/NULL';        }        if (!empty($published)) {            $url .= '/1';        }        return $this->_returnLink($url, $id);    }        /**     * Returns a link to download the total usage count group by day      *      * @param array $data with the following keys and values     *      'id' => (mixed) the id of the template. If set to 'all' the data     *       for all available templates will be provided.     *      'after' => (string) a date in the format yyyy-mm-dd that will     *       select usages that happened after it. Default value is an empty      *       string.     *      'before' => (string) a date in the format yyyy-mm-dd that will     *       select usages that happened before it. Default value is an empty      *       string.     * @param string $callback the callback name that we want to use for padded     * JSON responses. If empty or NULL plain JSON will be returned.     * @return string     * @access public     */    public function usageCount($data = array(), $callback = '')    {            if (!isset($data['id'])) {            $data['id'] = 'all';        }        $url = $this->_options['docxpressoInstallation']. '/RESTservices/predefined/usage_count/' . $data['id'];		        if (!empty($callback)) {            $url .= '/' . $callback;        }        //we build and options object with the search filters        $options = new \stdClass();        if (!empty($data['before'])) {            $options->before = $data['before'];        }        if (!empty($data['after'])) {            $options->after = $data['after'];        }        $opt = $this->base64_encode_url_safe(json_encode($options));		        return $this->_returnLink($url, $data['id'], $opt);    }        /**     * Returns a link to list of users in JSON(P) format from the associated     * Docxpresso SERVER installation     *      * @param string $callback the callback name that we want to use for padded     * JSON responses. If empty plain JSON will be returned.     * @return string     * @access public     */    public function userList($callback = '')    {            $url = $this->_options['docxpressoInstallation']. '/RESTservices/predefined/users';        if (!empty($callback)) {            $url .= '/' . $callback;        }               return $this->_returnLink($url);    }        /**     * Returns a link to check if the the user is logged into the associated     * Docxpresso SERVER installation     *      * @param string $callback the callback name that we want to use for padded     * JSON responses. If empty plain JSON will be returned.     * @return string     * @access public     */    public function checkUser($callback = '')    {            $url = $this->_options['docxpressoInstallation']. '/RESTservices/predefined/check_user';        if (!empty($callback)) {            $url .= '/' . $callback;        }               return $this->_returnLink($url);    }        /**     * Creates the link requested by all other methods     *      * @param string $url     * @param mixed $id     * @param mixed $opt     * @return string     * @access private     */    private function _returnLink($url, $id = NULL, $opt = NULL)    {        $uniqid = uniqid() . rand(99999, 9999999);        $timestamp = time();	        $control = '';        if (!empty($id)){            $control .=  $id . '-';        }         $control .= $timestamp . '-' . $uniqid;        if (!empty($opt)){            $control .= '-' . $opt;        }         $dataKey = sha1($control, true);        $masterKey = $this->_options['pKey'];        $APIKEY = bin2hex($this->sha1_hmac($masterKey, $dataKey));        //we should now redirect to Docxpresso        $addr = $url . '?';        $addr .= 'uniqid=' . $uniqid .'&';        $addr .= 'timestamp=' . $timestamp . '&';        $addr .= 'APIKEY=' . $APIKEY;        if(!empty($opt)){            $addr.= '&options=' . $opt;        }		        return $addr;    }    /**     * generates hmac with sha1     *      * This method has been taken from the Wikipedia:     * https://en.wikipedia.org/wiki/Hash-based_message_authentication_code     * This content is released under CC-BY-SA:     * http://creativecommons.org/licenses/by-sa/3.0/     *      */    private function sha1_hmac($key,$data,$blockSize=64,$opad=0x5c,$ipad=0x36)     {        // Keys longer than blocksize are shortened        if (strlen($key) > $blockSize) {            $key = sha1($key,true);	        }        // Keys shorter than blocksize are right, zero-padded (concatenated)        $key = str_pad($key,$blockSize,chr(0x00),STR_PAD_RIGHT);	        $o_key_pad = $i_key_pad = '';        for($i = 0;$i < $blockSize;$i++) {            $o_key_pad .= chr(ord(substr($key,$i,1)) ^ $opad);            $i_key_pad .= chr(ord(substr($key,$i,1)) ^ $ipad);        }        return sha1($o_key_pad.sha1($i_key_pad.$data,true),true);    }        /*********************************************/    /*               ACCESS CONTROL              */    /*      For data exchange with Docxpresso    */    /*********************************************/         /**     * Whenever interacting with Docxpresso via a requestDataURI or      * responseDataURI parameters of the documentPreview method there     * is an APIKEY based on HMAC that allows to identify petitions as     * legitimate.     * This method simplifies the task to check if the request is legitimate     * by returning a boolean value: true for authorized requests and false     * otherwise     *      * @param string $data the POST/GET variable data sent along with      * the request     * @param string $timestamp the POST/GET variable timestamp sent along with      * the request     * @param string $uniqid the POST/GET variable uniqid sent along with      * the request     * @param string $APIKEY the POST/GET variable APIKEY sent along with      * the request     * @return boolean     * @access public     */    public function checkAPIKEY($data, $timestamp, $uniqid, $APIKEY)    {        $forward = sha1($timestamp . '-' . $uniqid . '-' . $data , true);        $masterKey = $this->_options['pKey'];        $refAPIKEY = bin2hex($this->sha1_hmac($masterKey, $forward));        if ($refAPIKEY == $APIKEY){            return true;        } else {            return false;        }    }                /*********************************************/    /*               ADMIN METHODS               */    /* Only for use of platform administrators   */    /*********************************************/     /**     * Returns a link to modify the corresponding instance config     * This method is only accessible to the platform admins      *      * @param string $secret private key only accesible to paltform admins     * @param array $data with the following optional keys and values      *      'isActive' => (boolean) determines if the docxpresso installation     *       is active or not     *      'trusted' => (boolean) determines if the docxpresso installation     *       should be trusted to run custom JS     *      'plan' => (string) changes the associates instance plan     *      'policy' => (string) json encoded object including the policy     *       associated with the assigned plan.     *      'usageLimits' => (string) json encoded object including the limits     *       in the generation of documents for the assigned plan.     *      'batch' => (string) json encoded object including the policy     *       for the batch jobs associated with the current plan.     *      'analyticsRunSize' => (integer) max size of a custom analytics run.     * @return string     * @access public     */    public function modifyConfig($secret, $data = array())    {            //additional security        $masterKey = $this->_options['pKey'];        $secret = bin2hex($this->sha1_hmac($masterKey, $secret));                $url = $this->_options['docxpressoInstallation']. '/RESTservices/predefined/modify_config';        //we build and options object with the search filters        $options = new \stdClass();        $options->secret = $secret;        if (isset($data['isActive'])) {            $options->isActive = $data['isActive'];        }        if (isset($data['trusted'])) {            $options->trusted = $data['trusted'];        }        if (!empty($data['plan'])) {            $options->plan = $data['plan'];        }        if (!empty($data['policy'])) {            $options->policy = $data['policy'];        }        if (!empty($data['usageLimits'])) {            $options->usageLimits = $data['usageLimits'];        }        if (!empty($data['batch'])) {            $options->batch = $data['batch'];        }        if (!empty($data['analyticsRunSize'])) {            $options->analyticsRunSize = $data['analyticsRunSize'];        }        $opt = $this->base64_encode_url_safe(json_encode($options));		        return $this->_returnLink($url, NULL, $opt);      }        /**     * Returns a link to obtain the current configuratin and history data      *      * @param string $secret private key only accesible to paltform admins     *      * @return string     * @access public     */    public function getConfig($secret)    {            //additional security        $masterKey = $this->_options['pKey'];        $secret = bin2hex($this->sha1_hmac($masterKey, $secret));                $url = $this->_options['docxpressoInstallation']. '/RESTservices/predefined/get_config/' . $secret;		        return $this->_returnLink($url);      }}